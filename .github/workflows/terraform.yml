name: Terraform Cloud

on:
  push:
    branches: [ main ]
  workflow_dispatch:

jobs:
  terraform:
    runs-on: ubuntu-latest
    timeout-minutes: 35
    if: |
      contains(github.event.head_commit.message, 'terraform') ||
      github.event_name == 'workflow_dispatch'

    env:
      TF_CLOUD_ORGANIZATION: "wikisaas-org"             # ton org TFC
      TF_WORKSPACE: "wikisaas-platform"                 # ton workspace TFC
      CONFIG_DIRECTORY: "./terraform"                   # dossier contenant tes .tf

    outputs:
      ec2_public_ip:         ${{ steps.export_outputs.outputs.EC2_PUBLIC_IP }}
      ec2_public_dns:        ${{ steps.export_outputs.outputs.EC2_PUBLIC_DNS }}
      db_endpoints:          ${{ steps.export_outputs.outputs.DB_ENDPOINTS }}
      dns_records:           ${{ steps.export_outputs.outputs.DNS_RECORDS }}
      r2_bucket_name:        ${{ steps.export_outputs.outputs.R2_BUCKET_NAME }}
      r2_account_id:         ${{ steps.export_outputs.outputs.R2_ACCOUNT_ID }}
      r2_location:           ${{ steps.export_outputs.outputs.R2_LOCATION }}
      r2_bucket_endpoint:    ${{ steps.export_outputs.outputs.R2_BUCKET_ENDPOINT }}
      vpc_id:                ${{ steps.export_outputs.outputs.VPC_ID }}
      public_subnet_id:      ${{ steps.export_outputs.outputs.PUBLIC_SUBNET_ID }}
      rds_subnet_group:      ${{ steps.export_outputs.outputs.RDS_SUBNET_GROUP }}
      ec2_security_group_id: ${{ steps.export_outputs.outputs.EC2_SECURITY_GROUP_ID }}
      rds_security_group_id: ${{ steps.export_outputs.outputs.RDS_SECURITY_GROUP_ID }}
      
    steps:
      - uses: actions/checkout@v4

      # 1) Uploader la configuration vers Terraform Cloud
      - name: Upload configuration
        id: upload
        uses: hashicorp/tfc-workflows-github/actions/upload-configuration@v1.3.2
        with:
          token: ${{ secrets.TF_API_TOKEN }}            # Ensure this secret exists in your GitHub repository settings
          organization: ${{ env.TF_CLOUD_ORGANIZATION }}
          workspace: ${{ env.TF_WORKSPACE }}
          directory: ${{ env.CONFIG_DIRECTORY }}
          speculative: false

      # 2) Créer le run (Auto-apply dans TFC appliquera tout seul)
      - name: Create run
        id: create
        uses: hashicorp/tfc-workflows-github/actions/create-run@v1.3.2
        with:
          token: ${{ secrets.TF_API_TOKEN }}
          workspace: ${{ env.TF_WORKSPACE }}
          configuration_version: ${{ steps.upload.outputs.configuration_version_id }}

      # 3) Attendre la fin du run (poll de l’API TFC jusqu’à un état final)
      - name: Wait until run finishes
        shell: bash
        env:
          TFC_TOKEN: ${{ secrets.TF_API_TOKEN }}
          RUN_ID: ${{ steps.create.outputs.run_id }}
        run: |
          set -euo pipefail
          finals=("applied" "planned_and_finished" "canceled" "errored" "discarded")
          echo "Polling run $RUN_ID"
          for i in {1..180}; do
            RESP=$(curl -sS -w " HTTP_CODE:%{http_code}" \
              -H "Authorization: Bearer $TFC_TOKEN" \
              -H "Content-Type: application/vnd.api+json" \
              "https://app.terraform.io/api/v2/runs/$RUN_ID") || true
            CODE="${RESP##*HTTP_CODE:}"; BODY="${RESP% HTTP_CODE:*}"
            [[ "$CODE" != "200" ]] && echo "HTTP $CODE, retry..." && sleep 10 && continue
            STATUS=$(printf '%s' "$BODY" | jq -r '.data.attributes.status // ""' | tr -d '\r' | xargs)
            echo "Run Status: '$STATUS'"
            for f in "${finals[@]}"; do
              if [[ "$STATUS" == "$f" ]]; then
                echo "Final status: $STATUS"
                [[ "$STATUS" == "applied" || "$STATUS" == "planned_and_finished" ]] && exit 0 || exit 1
              fi
            done
            sleep 10
          done
          echo "Timeout waiting for run to finish"
          exit 1

      # 4) Lire les outputs avec le CLI Terraform (après init)
      - name: Setup Terraform CLI
        uses: hashicorp/setup-terraform@v3
        with:
          cli_config_credentials_token: ${{ secrets.TF_API_TOKEN }}
          terraform_wrapper: false   # indispensable pour terraform output , le petit changement

      - name: Terraform Init (pointe vers TFC via le bloc cloud)
        run: terraform -chdir=${{ env.CONFIG_DIRECTORY }} init -input=false

      - name: Terraform Output
        run: terraform -chdir=${{ env.CONFIG_DIRECTORY }} output

      - name: Exporter outputs Terraform
        id: export_outputs
        run: |
          set -euo pipefail
          O=$(terraform -chdir=${{ env.CONFIG_DIRECTORY }} output -json)

          echo "EC2_PUBLIC_IP=$(echo "$O" | jq -r .ec2_public_ip.value)" >> $GITHUB_OUTPUT
          echo "EC2_PUBLIC_DNS=$(echo "$O" | jq -r .ec2_public_dns.value)" >> $GITHUB_OUTPUT
          echo "DB_ENDPOINTS=$(echo "$O" | jq -c '.db_endpoints.value | with_entries(.value |= .host)')" >> $GITHUB_OUTPUT
          echo "DNS_RECORDS=$(echo "$O" | jq -c .dns_records.value)" >> $GITHUB_OUTPUT
          echo "R2_BUCKET_NAME=$(echo "$O" | jq -r .r2_bucket_name.value)" >> $GITHUB_OUTPUT
          echo "R2_ACCOUNT_ID=$(echo "$O" | jq -r .r2_account_id.value)" >> $GITHUB_OUTPUT
          echo "R2_LOCATION=$(echo "$O" | jq -r .r2_location.value)" >> $GITHUB_OUTPUT
          echo "R2_BUCKET_ENDPOINT=$(echo "$O" | jq -r .r2_bucket_endpoint.value)" >> $GITHUB_OUTPUT
          echo "VPC_ID=$(echo "$O" | jq -r .vpc_id.value)" >> $GITHUB_OUTPUT
          echo "PUBLIC_SUBNET_ID=$(echo "$O" | jq -r .public_subnet_id.value)" >> $GITHUB_OUTPUT
          echo "RDS_SUBNET_GROUP=$(echo "$O" | jq -r .rds_subnet_group.value)" >> $GITHUB_OUTPUT
          echo "EC2_SECURITY_GROUP_ID=$(echo "$O" | jq -r .ec2_security_group_id.value)" >> $GITHUB_OUTPUT
          echo "RDS_SECURITY_GROUP_ID=$(echo "$O" | jq -r .rds_security_group_id.value)" >> $GITHUB_OUTPUT


  ansible:
    runs-on: ubuntu-latest
    needs: [terraform]   # attend Terraform seulement si Terraform est déclenché
  
    env: 
       # Secrets GitHub
      ADMIN_PASS_CYBER: ${{ secrets.ADMIN_PASS_CYBER }}
      ADMIN_PASS_DEVOPS: ${{ secrets.ADMIN_PASS_DEVOPS }}
      ADMIN_PASS_IA: ${{ secrets.ADMIN_PASS_IA }}
      BDD_PASSWORD: ${{ secrets.BDD_PASSWORD }}
      CLOUDFLARE_API_TOKEN: ${{ secrets.CLOUDFLARE_API_TOKEN }}
      CLOUDFLARE_API_TOKEN_R2: ${{ secrets.CLOUDFLARE_API_TOKEN_R2 }}
      DB_PASSWORD: ${{ secrets.DB_PASSWORD }}
      KEYCLOAK_ADMIN_PASS: ${{ secrets.KEYCLOAK_ADMIN_PASS }}
      R2_ACCESS_KEY: ${{ secrets.R2_ACCESS_KEY }}
      R2_SECRET_KEY: ${{ secrets.R2_SECRET_KEY }}
      TF_API_TOKEN: ${{ secrets.TF_API_TOKEN }}
      KEYCLOAK_DB_PASSWORD: ${{ secrets.KEYCLOAK_DB_PASSWORD }}
      VM_SSH_KEY: ${{ secrets.VM_SSH_KEY }}
    steps:
      - uses: actions/checkout@v4

      - name: Setup SSH key
        run: |
          mkdir -p ~/.ssh
          echo "$VM_SSH_KEY" | sed 's/\\n/\n/g' > ~/.ssh/newtest.pem
          chmod 600 ~/.ssh/newtest.pem

      - name: Install Ansible
        run: sudo apt-get update && sudo apt-get install -y ansible

      - name: Install Ansible collections
        run: ansible-galaxy collection install ansible.posix

      - name: Add SSH known_hosts
        run: |
          mkdir -p ~/.ssh
          ssh-keyscan -H wikiplatform.app >> ~/.ssh/known_hosts

      - name: Run Ansible Playbook
        run: |
          ansible-playbook \
            -i ansible/inventories/prod/hosts.ini \
            ansible/site.yml \
            --extra-vars "ec2_public_ip=${{ needs.terraform.outputs.ec2_public_ip }} \
                          ec2_public_dns=${{ needs.terraform.outputs.ec2_public_dns }} \
                          db_endpoints='${{ needs.terraform.outputs.db_endpoints }}' \
                          dns_records='${{ needs.terraform.outputs.dns_records }}' \
                          r2_bucket_name=${{ needs.terraform.outputs.r2_bucket_name }} \
                          r2_account_id=${{ needs.terraform.outputs.r2_account_id }} \
                          r2_location=${{ needs.terraform.outputs.r2_location }} \
                          r2_bucket_endpoint=${{ needs.terraform.outputs.r2_bucket_endpoint }} \
                          vpc_id=${{ needs.terraform.outputs.vpc_id }} \
                          public_subnet_id=${{ needs.terraform.outputs.public_subnet_id }} \
                          rds_subnet_group=${{ needs.terraform.outputs.rds_subnet_group }} \
                          ec2_security_group_id=${{ needs.terraform.outputs.ec2_security_group_id }} \
                          rds_security_group_id=${{ needs.terraform.outputs.rds_security_group_id }}"

