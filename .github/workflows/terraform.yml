name: Terraform Cloud

on:
  push:
    branches: [ main ]
  workflow_dispatch:

jobs:
  terraform:
    runs-on: ubuntu-latest
    timeout-minutes: 35

    env:
      TF_CLOUD_ORGANIZATION: "wikisaas-org"             # ton org TFC
      TF_WORKSPACE: "wikisaas-platform"                 # ton workspace TFC
      CONFIG_DIRECTORY: "./terraform"                   # dossier contenant tes .tf

    steps:
      - uses: actions/checkout@v4

      # 1) Uploader la configuration vers Terraform Cloud
      - name: Upload configuration
        id: upload
        uses: hashicorp/tfc-workflows-github/actions/upload-configuration@v1.3.2
        with:
          token: ${{ secrets.TF_API_TOKEN }}            # SECRET GitHub à créer
          organization: ${{ env.TF_CLOUD_ORGANIZATION }}
          workspace: ${{ env.TF_WORKSPACE }}
          directory: ${{ env.CONFIG_DIRECTORY }}
          speculative: false

      # 2) Créer le run (Auto-apply dans TFC appliquera tout seul)
      - name: Create run
        id: create
        uses: hashicorp/tfc-workflows-github/actions/create-run@v1.3.2
        with:
          token: ${{ secrets.TF_API_TOKEN }}
          workspace: ${{ env.TF_WORKSPACE }}
          configuration_version: ${{ steps.upload.outputs.configuration_version_id }}

      # 3) Attendre la fin du run (poll de l’API TFC jusqu’à un état final)
      - name: Wait until run finishes
        shell: bash
        env:
          TFC_TOKEN: ${{ secrets.TF_API_TOKEN }}
          RUN_ID: ${{ steps.create.outputs.run_id }}
        run: |
          set -euo pipefail
          finals=("applied" "planned_and_finished" "canceled" "errored" "discarded")
          echo "Polling run $RUN_ID"
          for i in {1..180}; do
            RESP=$(curl -sS -w " HTTP_CODE:%{http_code}" \
              -H "Authorization: Bearer $TFC_TOKEN" \
              -H "Content-Type: application/vnd.api+json" \
              "https://app.terraform.io/api/v2/runs/$RUN_ID") || true
            CODE="${RESP##*HTTP_CODE:}"; BODY="${RESP% HTTP_CODE:*}"
            [[ "$CODE" != "200" ]] && echo "HTTP $CODE, retry..." && sleep 10 && continue
            STATUS=$(printf '%s' "$BODY" | jq -r '.data.attributes.status // ""' | tr -d '\r' | xargs)
            echo "Run Status: '$STATUS'"
            for f in "${finals[@]}"; do
              if [[ "$STATUS" == "$f" ]]; then
                echo "Final status: $STATUS"
                [[ "$STATUS" == "applied" || "$STATUS" == "planned_and_finished" ]] && exit 0 || exit 1
              fi
            done
            sleep 10
          done
          echo "Timeout waiting for run to finish"
          exit 1

      # 4) Lire les outputs avec le CLI Terraform (après init)
      - name: Setup Terraform CLI
        uses: hashicorp/setup-terraform@v3
        with:
          cli_config_credentials_token: ${{ secrets.TF_API_TOKEN }}

      - name: Terraform Init (pointe vers TFC via le bloc cloud)
        run: terraform -chdir=${{ env.CONFIG_DIRECTORY }} init -input=false

      - name: Terraform Output
        run: terraform -chdir=${{ env.CONFIG_DIRECTORY }} output

      - name: Exporter outputs Terraform
        run: |
          set -euo pipefail
          O=$(terraform -chdir=${{ env.CONFIG_DIRECTORY }} output -json)

          echo "EC2_PUBLIC_IP=$(echo "$O" | jq -r .ec2_public_ip.value)" >> $GITHUB_ENV
          echo "EC2_PUBLIC_DNS=$(echo "$O" | jq -r .ec2_public_dns.value)" >> $GITHUB_ENV
          echo "DB_ENDPOINTS=$(echo "$O" | jq -c .db_endpoints.value)" >> $GITHUB_ENV
          echo "DNS_RECORDS=$(echo "$O" | jq -c .dns_records.value)" >> $GITHUB_ENV
          echo "R2_BUCKET_NAME=$(echo "$O" | jq -r .r2_bucket_name.value)" >> $GITHUB_ENV
          echo "R2_ACCOUNT_ID=$(echo "$O" | jq -r .r2_account_id.value)" >> $GITHUB_ENV
          echo "R2_LOCATION=$(echo "$O" | jq -r .r2_location.value)" >> $GITHUB_ENV
          echo "R2_BUCKET_ENDPOINT=$(echo "$O" | jq -r .r2_bucket_endpoint.value)" >> $GITHUB_ENV
          echo "VPC_ID=$(echo "$O" | jq -r .vpc_id.value)" >> $GITHUB_ENV
          echo "PUBLIC_SUBNET_ID=$(echo "$O" | jq -r .public_subnet_id.value)" >> $GITHUB_ENV
          echo "RDS_SUBNET_GROUP=$(echo "$O" | jq -r .rds_subnet_group.value)" >> $GITHUB_ENV
          echo "EC2_SECURITY_GROUP_ID=$(echo "$O" | jq -r .ec2_security_group_id.value)" >> $GITHUB_ENV
          echo "RDS_SECURITY_GROUP_ID=$(echo "$O" | jq -r .rds_security_group_id.value)" >> $GITHUB_ENV
