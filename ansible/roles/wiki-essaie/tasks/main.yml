---
- name: Créer le dossier Wiki.js
  become: true
  file:
    path: /opt/wiki
    state: directory
    owner: root
    group: root
    mode: '0755'

- name: Créer le dossier des fichiers .env pour Wiki.js
  become: true
  file:
    path: /opt/wiki/envs
    state: directory
    owner: root
    group: root
    mode: '0755'

- name: Supprimer les anciens fichiers .env
  file:
    path: "/opt/wiki/envs/wiki-{{ item.name }}.env"
    state: absent
  loop: "{{ wikis }}"

- name: Créer le dossier des certificats RDS
  become: true
  file:
    path: /opt/wiki/certs
    state: directory
    owner: root
    group: root
    mode: '0755'

- name: Télécharger le certificat SSL RDS global
  become: true
  get_url:
    url: https://truststore.pki.rds.amazonaws.com/global/global-bundle.pem
    dest: /opt/wiki/certs/rds-ca-bundle.pem
    mode: '0644'


- name: Copier le docker-compose.yml de Wiki.js
  become: true
  copy:
    src: docker-compose.yml        # ton fichier compose (dans roles/wiki/files/)
    dest: /opt/wiki/docker-compose.yml
    mode: '0644'
  notify: Restart Wiki.js

  # -------------------------------------------------------------------
# Étape 1 : Lire le fichier clients.json sur la VM
# -------------------------------------------------------------------
- name: Lire clients.json sur la VM
  slurp:
    src: /opt/keycloak/clients.json  # chemin du fichier côté machine distante (VM)
  register: kc_clients_raw    # on stocke le contenu brut (encodé en base64) dans cette variable

# -------------------------------------------------------------------
# Étape 2 : Transformer le contenu en variable JSON utilisable
# -------------------------------------------------------------------
- name: Convertir clients.json en dictionnaire
  set_fact:
    # kc_clients_raw.content = contenu du fichier en base64
    # b64decode = décoder le base64
    # from_json = parser le texte JSON en dictionnaire Python/Ansible
    kc_clients: "{{ kc_clients_raw.content | b64decode | from_json }}"
    # Résultat final : kc_clients = dictionnaire utilisable dans les templates
    # Exemple :
    # kc_clients['ia']     -> secret du client wiki-ia
    # kc_clients['devops'] -> secret du client wiki-devops
    # kc_clients['cyber']  -> secret du client wiki-cyber

- name: Générer les fichiers .env pour chaque instance Wiki.js
  become: true
  template:
    src: env.j2                    # ton template (dans roles/wiki/templates/)
    dest: "/opt/wiki/envs/wiki-{{ item.name }}.env"
    mode: '0644'
  loop: "{{ wikis }}"              # défini dans group_vars/all.yml
  notify: Restart Wiki.js

- name: Copier le Dockerfile Postgres custom
  copy:
    src: Dockerfile.postgres     # placé dans roles/wiki-essaie/files/
    dest: /opt/wiki/Dockerfile.postgres
    mode: '0644'

- name: Construire l’image Postgres custom avec Python
  community.docker.docker_image:
    name: postgres-python
    tag: "15"
    build:
      path: /opt/wiki     # ou le chemin où tu as mis ton Dockerfile.postgres
      dockerfile: Dockerfile.postgres
    source: build
    state: present

- name: Déployer Wiki.js avec Docker Compose v2
  become: true
  community.docker.docker_compose_v2:
    project_src: /opt/wiki
    state: present
  notify: Restart Wiki.js
# -------------------------------------------------------------------
# Étape 3 : Configurer les bases de données dans les conteneurs Docker
# -------------------------------------------------------------------
- name: Attendre que les DB Docker soient prêtes
  command: docker exec {{ item.pg_host }} pg_isready -U {{ item.pg_user }} -d {{ item.pg_db }}
  register: pg_ready
  retries: 10
  delay: 6
  until: pg_ready.rc == 0
  loop: "{{ wikis_docker }}"
  loop_control:
    label: "{{ item.name }}"

# Installer l’extension pgcrypto (nécessaire pour certaines fonctions de sécurité dans Wiki.js)

- name: Activer pgcrypto si non présent (sécurité)
  command: >
    docker exec -i {{ item.pg_host }}
    psql -U {{ item.pg_user }} -d {{ item.pg_db }}
    -c "CREATE EXTENSION IF NOT EXISTS pgcrypto;"
  loop: "{{ wikis_docker }}"
  loop_control:
    label: "{{ item.name }}"
  when: item.pg_host is defined
# on peut ignorer l’erreur si elle existe déjà
- name: Ajouter contrainte UNIQUE sur strategyKey dans authentication
  command: >
    docker exec -i {{ item.pg_host }}
    psql -U {{ item.pg_user }} -d {{ item.pg_db }} -c "
      ALTER TABLE authentication
      ADD CONSTRAINT authentication_strategykey_unique
      UNIQUE (\"strategyKey\");
    "
  loop: "{{ wikis_docker }}"
  loop_control:
    label: "{{ item.name }}"
  ignore_errors: true

# Configurer Keycloak comme méthode d’authentification (sso)dans Wiki.js
- name: Configurer Keycloak dans la table authentication (DB Docker)
  command: >
    docker exec -i {{ item.pg_host }}
    psql -U {{ item.pg_user }} -d {{ item.pg_db }} -t -A -c "
    INSERT INTO authentication
     (\"key\", \"strategyKey\", \"displayName\", \"isEnabled\", \"order\",
      \"config\", \"selfRegistration\", \"domainWhitelist\", \"autoEnrollGroups\")
    VALUES (
      gen_random_uuid(),
      'keycloak',
      'Keycloak',
      true,
      1,
      jsonb_build_object(
        'host', 'https://sso.{{ base_domain }}',
        'realm', 'saas',
        'clientId', '{{ item.name }}',
        'clientSecret', '{{ kc_clients[item.name] }}',
        'authorizationURL', 'https://sso.{{ base_domain }}/realms/saas/protocol/openid-connect/auth',
        'tokenURL',        'https://sso.{{ base_domain }}/realms/saas/protocol/openid-connect/token',
        'userInfoURL',     'https://sso.{{ base_domain }}/realms/saas/protocol/openid-connect/userinfo',
        'logoutURL',       'https://sso.{{ base_domain }}/realms/saas/protocol/openid-connect/logout',
        'logoutUpstream', false,
        'logoutUpstreamRedirectLegacy', false
      ),
      false,
      '[]'::json,
      '[]'::json
    )
    ON CONFLICT (\"strategyKey\") DO UPDATE
      SET config = EXCLUDED.config;"
  register: keycloak_insert
  changed_when: "'INSERT 0 1' in keycloak_insert.stdout or 'UPDATE' in keycloak_insert.stdout"
  loop: "{{ wikis_docker }}"
  loop_control:
    label: "{{ item.name }}"

# Installer pip3 (nécessaire pour installer passlib)
- name: Installer pip3 (Ubuntu)
  become: true
  apt:
    name: python3-pip
    state: present
    update_cache: true

# Installer la librairie Python passlib avec le module bcrypt :
# - nécessaire pour que le filtre Ansible `password_hash("bcrypt")` fonctionne
# - utilisé pour générer et insérer des mots de passe hashés dans Wiki.js
- name: Installer passlib via apt (Ubuntu)
  become: true
  apt:
    name: python3-passlib
    state: present
    update_cache: true

# Configurer R2 (S3 compatible) comme stockage de fichiers dans Wiki.js
- name: Configurer R2 dans la table storage (DB Docker)
  command: >
    docker exec -i {{ item.pg_host }}
    psql -U {{ item.pg_user }} -d {{ item.pg_db }} -c
    "INSERT INTO storage (\"key\", \"isEnabled\", mode, config, \"syncInterval\", state)
     VALUES (
       's3generic',
       true,
       'push',
       jsonb_build_object(
         'endpoint', '{{ s3_endpoint }}',
         'bucket', '{{ s3_bucket }}',
         'accessKeyId', '{{ s3_access_key }}',
         'secretAccessKey', '{{ s3_secret_key }}',
         'sslEnabled', true,
         's3ForcePathStyle', true,
         's3BucketEndpoint', false
       ),
       '0 */12 * * *',
       '{}'::json
     )
     ON CONFLICT (\"key\") DO UPDATE
     SET \"isEnabled\"    = EXCLUDED.\"isEnabled\",
         mode             = EXCLUDED.mode,
         config           = EXCLUDED.config,
         \"syncInterval\" = EXCLUDED.\"syncInterval\",
         state            = '{}'::json;"
  loop: "{{ wikis_docker }}"
  loop_control:
    label: "{{ item.name }}"


# -------------------------------------------------------------------
# Créer un provider "local" dans Wiki.js (table authentication)
# - Définit une méthode d’authentification locale en plus de Keycloak
# - Utile comme solution de secours (admin peut se connecter même si SSO tombe en panne)
# - Conflit évité si déjà présent (ON CONFLICT DO NOTHING)
# -------------------------------------------------------------------
# - name: Créer le provider local dans la table authentication
#   command: >
#     docker exec -i {{ item.pg_host }}
#     psql -U {{ item.pg_user }} -d {{ item.pg_db }} -c "
#     INSERT INTO authentication
#         (\"key\", \"strategyKey\", \"displayName\", \"isEnabled\", \"order\",
#          \"config\", \"selfRegistration\", \"domainWhitelist\", \"autoEnrollGroups\")
#       VALUES (
#         gen_random_uuid(), 'local', 'Local Authentication', true, 0,
#         '{}'::json, false, '[]'::json, '[]'::json
#       )
#       ON CONFLICT (\"strategyKey\") DO NOTHING;"
#   register: local_insert
#   changed_when: "'INSERT 0 1' in local_insert.stdout"
#   loop: "{{ wikis_docker }}"
#   loop_control:
#     label: "{{ item.name }}"


# -------------------------------------------------------------------
#- name: Upsert locale 'en' (PK sur code)
#  command: >
#    docker exec -i {{ item.pg_host }}
#    psql -U {{ item.pg_user }} -d {{ item.pg_db }} -v ON_ERROR_STOP=1 -c "
#    psql -U {{ item.pg_user }} -d {{ item.pg_db }} -v ON_ERROR_STOP=1 -c "
#   INSERT INTO locales (
#      code, strings, \"isRTL\", name, \"nativeName\",
#     availability, \"createdAt\", \"updatedAt\"
#   ) VALUES (
#     'en', '{}'::json, false, 'English', 'English',
#     0,
#     to_char(NOW(), 'YYYY-MM-DD\"T\"HH24:MI:SS\"Z\"'),
#     to_char(NOW(), 'YYYY-MM-DD\"T\"HH24:MI:SS\"Z\"')
#    )
#    ON CONFLICT (code) DO UPDATE SET
#      strings      = EXCLUDED.strings,
#      \"isRTL\"     = EXCLUDED.\"isRTL\",
#      name         = EXCLUDED.name,
#      \"nativeName\"= EXCLUDED.\"nativeName\",
#      availability = EXCLUDED.availability,
#      \"updatedAt\" = EXCLUDED.\"updatedAt\";
#    "
#  changed_when: false
#  loop: "{{ wikis_docker }}"
#  loop_control:
#    label: "{{ item.name }}"

#- name: Seed editors (markdown / wysiwyg / code)
#  command: >
#    docker exec -i {{ item.pg_host }}
#    psql -U {{ item.pg_user }} -d {{ item.pg_db }} -v ON_ERROR_STOP=1 -c "
#    INSERT INTO editors (key, \"isEnabled\", config) VALUES
#      ('markdown', true, '{}'::json),
#      ('wysiwyg',  true, '{}'::json),
#      ('code',     true, '{}'::json)
#    ON CONFLICT (key) DO UPDATE
#      SET \"isEnabled\" = EXCLUDED.\"isEnabled\",
#          config        = EXCLUDED.config;
#    "
#  changed_when: false
#  loop: "{{ wikis_docker }}"
#  loop_control:
#    label: "{{ item.name }}"
#
#
# -------------------------------------------------------------------
# Créer un compte admin local dans chaque DB Wiki.js
# - Compte administrateur initial avec email et mot de passe hashé (passlib)
# - Sert pour la première connexion avant configuration Keycloak
# - Si l’admin existe déjà, met à jour son mot de passe et réactive le compte
# -------------------------------------------------------------------
#- name: Créer un compte admin local dans chaque DB Docker
#  command: >
#    docker exec -i {{ item.pg_host }}
#    psql -U {{ item.pg_user }} -d {{ item.pg_db }} -c "
#    INSERT INTO users (
#     email, name, password,
#      \"isSystem\", \"isActive\", \"isVerified\", \"mustChangePwd\", \"tfaIsActive\",
#      \"providerKey\", \"providerId\",
#      \"createdAt\", \"updatedAt\",
#      \"localeCode\", \"defaultEditor\", \"timezone\",
#      \"lastLoginAt\", \"dateFormat\", \"appearance\"
#    ) VALUES (
#      '{{ item.admin_email }}',
#      'Administrator',
#      '{{ item.admin_password }}',
#      true, true, true, false, false,
#      (SELECT \"key\" FROM authentication WHERE \"strategyKey\"='local' LIMIT 1),
#      '',
#      to_char(NOW(), 'YYYY-MM-DD\"T\"HH24:MI:SS\"Z\"'),
#      to_char(NOW(), 'YYYY-MM-DD\"T\"HH24:MI:SS\"Z\"'),
#      'en', 'markdown', 'America/Toronto',
#      to_char(NOW(), 'YYYY-MM-DD\"T\"HH24:MI:SS\"Z\"'),
#       'YYYY-MM-DD', 'default'
#    )
#    ON CONFLICT (\"providerKey\", email) DO UPDATE
#    SET \"password\" = EXCLUDED.\"password\",
#        \"isActive\" = true,
#        \"isVerified\" = true,
#        \"updatedAt\" = to_char(NOW(), 'YYYY-MM-DD"T"HH24:MI:SS"Z"');"
#
#  changed_when: false
#  loop: "{{ wikis_docker }}"
#  loop_control:
#    label: "{{ item.name }}"
