---
- name: Créer le dossier Wiki.js
  become: true
  file:
    path: /opt/wiki
    state: directory
    owner: root
    group: root
    mode: '0755'

- name: Créer le dossier des fichiers .env pour Wiki.js
  become: true
  file:
    path: /opt/wiki/envs
    state: directory
    owner: root
    group: root
    mode: '0755'

- name: Supprimer les anciens fichiers .env
  file:
    path: "/opt/wiki/envs/wiki-{{ item.name }}.env"
    state: absent
  loop: "{{ wikis }}"

- name: Créer le dossier des certificats RDS
  become: true
  file:
    path: /opt/wiki/certs
    state: directory
    owner: root
    group: root
    mode: '0755'

- name: Télécharger le certificat SSL RDS global
  become: true
  get_url:
    url: https://truststore.pki.rds.amazonaws.com/global/global-bundle.pem
    dest: /opt/wiki/certs/rds-ca-bundle.pem
    mode: '0644'


- name: Copier le docker-compose.yml de Wiki.js
  become: true
  copy:
    src: docker-compose.yml        # ton fichier compose (dans roles/wiki/files/)
    dest: /opt/wiki/docker-compose.yml
    mode: '0644'
  notify: Restart Wiki.js

  # -------------------------------------------------------------------
# Étape 1 : Lire le fichier clients.json sur la VM
# -------------------------------------------------------------------
- name: Lire clients.json sur la VM
  slurp:
    src: /opt/keycloak/clients.json  # chemin du fichier côté machine distante (VM)
  register: kc_clients_raw    # on stocke le contenu brut (encodé en base64) dans cette variable

# -------------------------------------------------------------------
# Étape 2 : Transformer le contenu en variable JSON utilisable
# -------------------------------------------------------------------
- name: Convertir clients.json en dictionnaire
  set_fact:
    # kc_clients_raw.content = contenu du fichier en base64
    # b64decode = décoder le base64
    # from_json = parser le texte JSON en dictionnaire Python/Ansible
    kc_clients: "{{ kc_clients_raw.content | b64decode | from_json }}"
    # Résultat final : kc_clients = dictionnaire utilisable dans les templates
    # Exemple :
    # kc_clients['ia']     -> secret du client wiki-ia
    # kc_clients['devops'] -> secret du client wiki-devops
    # kc_clients['cyber']  -> secret du client wiki-cyber

- name: Générer les fichiers .env pour chaque instance Wiki.js
  become: true
  template:
    src: env.j2                    # ton template (dans roles/wiki/templates/)
    dest: "/opt/wiki/envs/wiki-{{ item.name }}.env"
    mode: '0644'
  loop: "{{ wikis }}"              # défini dans group_vars/all.yml
  notify: Restart Wiki.js

- name: Copier le Dockerfile Postgres custom
  copy:
    src: Dockerfile.postgres     # placé dans roles/wiki-essaie/files/
    dest: /opt/wiki/Dockerfile.postgres
    mode: '0644'

- name: Construire l’image Postgres custom avec Python
  community.docker.docker_image:
    name: postgres-python
    tag: "15"
    build:
      path: /opt/wiki     # ou le chemin où tu as mis ton Dockerfile.postgres
      dockerfile: Dockerfile.postgres
    source: build
    state: present

- name: Déployer Wiki.js avec Docker Compose v2
  become: true
  community.docker.docker_compose_v2:
    project_src: /opt/wiki
    state: present
  notify: Restart Wiki.js
# -------------------------------------------------------------------
# Étape 3 : Configurer les bases de données dans les conteneurs Docker 
# ------------------------------------------------------------------- 
- name: Attendre que les DB Docker soient prêtes
  command: docker exec {{ item.pg_host }} pg_isready -U {{ item.pg_user }} -d {{ item.pg_db }}
  register: pg_ready
  retries: 10
  delay: 6
  until: pg_ready.rc == 0
  loop: "{{ wikis_docker }}"
  loop_control:
    label: "{{ item.name }}"

# Installer l’extension pgcrypto (nécessaire pour certaines fonctions de sécurité dans Wiki.js)  

- name: Activer pgcrypto si non présent (sécurité)
  command: >
    docker exec -i {{ item.pg_host }}
    psql -U {{ item.pg_user }} -d {{ item.pg_db }}
    -c "CREATE EXTENSION IF NOT EXISTS pgcrypto;"
  loop: "{{ wikis_docker }}"
  loop_control:
    label: "{{ item.name }}"
  when: item.pg_host is defined

  # Configurer Keycloak comme méthode d’authentification (sso)dans Wiki.js
- name: Configurer Keycloak dans la table authentication (DB Docker)
  command: >
    docker exec -i {{ item.pg_host }}
    psql -U {{ item.pg_user }} -d {{ item.pg_db }} -c
    "INSERT INTO authentication
     (\"key\", \"strategyKey\", \"displayName\", \"isEnabled\", \"order\",
      \"config\", \"selfRegistration\", \"domainWhitelist\", \"autoEnrollGroups\")
     VALUES (
       gen_random_uuid(),
       'keycloak',
       'Keycloak',
       true,
       1,
       jsonb_build_object(
         'host', 'https://sso.{{ base_domain }}',
         'realm', 'saas',
         'clientId', '{{ item.name }}',
         'clientSecret', '{{ kc_clients[item.name] }}',
         'authorizationURL', 'https://sso.{{ base_domain }}/realms/saas/protocol/openid-connect/auth',
         'tokenURL',        'https://sso.{{ base_domain }}/realms/saas/protocol/openid-connect/token',
         'userInfoURL',     'https://sso.{{ base_domain }}/realms/saas/protocol/openid-connect/userinfo',
         'logoutURL',       'https://sso.{{ base_domain }}/realms/saas/protocol/openid-connect/logout',
         'logoutUpstream', false,
         'logoutUpstreamRedirectLegacy', false
       ),
       false,
       '[]'::json,
       '[]'::json
     )
     ON CONFLICT DO NOTHING;"
  loop: "{{ wikis_docker }}"
  loop_control:
    label: "{{ item.name }}"

- name: Installer pip3 (Ubuntu)
  become: true
  apt:
    name: python3-pip
    state: present
    update_cache: true

# Installer la librairie Python passlib avec le module bcrypt :
# - nécessaire pour que le filtre Ansible `password_hash("bcrypt")` fonctionne
# - utilisé pour générer et insérer des mots de passe hashés dans Wiki.js
- name: Installer passlib via apt (Ubuntu)
  become: true
  apt:
    name: python3-passlib
    state: present
    update_cache: true

- name: Configurer R2 dans la table storage (DB Docker)
  command: >
    docker exec -i {{ item.pg_host }}
    psql -U {{ item.pg_user }} -d {{ item.pg_db }} -c
    "INSERT INTO storage (\"key\", \"isEnabled\", mode, config, \"syncInterval\", state)
     VALUES (
       's3generic',
       true,
       'push',
       jsonb_build_object(
         'endpoint', '{{ s3_endpoint }}',
         'bucket', '{{ s3_bucket }}',
         'accessKeyId', '{{ s3_access_key }}',
         'secretAccessKey', '{{ s3_secret_key }}',
         'sslEnabled', true,
         's3ForcePathStyle', true,
         's3BucketEndpoint', false
       ),
       '0 */12 * * *',
       '{}'::json
     )
     ON CONFLICT (\"key\") DO UPDATE
     SET \"isEnabled\"    = EXCLUDED.\"isEnabled\",
         mode             = EXCLUDED.mode,
         config           = EXCLUDED.config,
         \"syncInterval\" = EXCLUDED.\"syncInterval\",
         state            = '{}'::json;"
  loop: "{{ wikis_docker }}"
  loop_control:
    label: "{{ item.name }}"


# -------------------------------------------------------------------
# Ajouter la locale 'en' si elle n'existe pas déjà
# - Vérifie la présence de la colonne isrtl (Wiki.js v2 peut avoir un schéma différent)
# - Insère la locale "English" avec compatibilité ascendante
# - Evite les erreurs si la locale est déjà présente (ON CONFLICT DO NOTHING)
# -------------------------------------------------------------------
# - name: Ajouter la locale 'en' si absente (compatible toutes versions)
#   command: >
#     docker exec -i {{ item.pg_host }}
#     psql -U {{ item.pg_user }} -d {{ item.pg_db }} -c "
#     DO $$
#     BEGIN
#       IF EXISTS (
#         SELECT 1 FROM information_schema.columns
#         WHERE table_name='locales' AND column_name='isrtl'
#       ) THEN
#         INSERT INTO locales (code, strings, \"isRTL\", name, nativeName, availability, createdAt, updatedAt)
#         VALUES ('en', '{}'::json, false, 'English', 'English', 'production', NOW(), NOW())
#         ON CONFLICT (code) DO NOTHING;
#       ELSE
#         INSERT INTO locales (code, strings, name, nativeName, availability, createdAt, updatedAt)
#         VALUES ('en', '{}'::json, 'English', 'English', 'production', NOW(), NOW())
#         ON CONFLICT (code) DO NOTHING;
#       END IF;
#     END$$;"
#   changed_when: false
#   loop: "{{ wikis_docker }}"
#   loop_control:
#     label: "{{ item.name }}"

# -------------------------------------------------------------------
# Créer un provider "local" dans Wiki.js (table authentication)
# - Définit une méthode d’authentification locale en plus de Keycloak
# - Utile comme solution de secours (admin peut se connecter même si SSO tombe en panne)
# - Conflit évité si déjà présent (ON CONFLICT DO NOTHING)
# -------------------------------------------------------------------
# - name: Créer le provider local dans la table authentication
#   command: >
#     docker exec -i {{ item.pg_host }}
#     psql -U {{ item.pg_user }} -d {{ item.pg_db }} -c
#     "INSERT INTO authentication
#      (\"key\", \"strategyKey\", \"displayName\", \"isEnabled\", \"order\",
#       \"config\", \"selfRegistration\", \"domainWhitelist\", \"autoEnrollGroups\")
#      VALUES (
#       '00000000-0000-0000-0000-000000000000', 'local', 'Local', true, 0, '{}'::json,
#       false, '[]'::json, '[]'::json
#     )
#     ON CONFLICT DO NOTHING;"
#   changed_when: false
#   loop: "{{ wikis_docker }}"
#   loop_control:
#     label: "{{ item.name }}"

# -------------------------------------------------------------------
# Créer un compte admin local dans chaque DB Wiki.js
# - Compte administrateur initial avec email et mot de passe hashé (passlib)
# - Sert pour la première connexion avant configuration Keycloak
# - Si l’admin existe déjà, met à jour son mot de passe et réactive le compte
# -------------------------------------------------------------------
# - name: Créer un compte admin local dans chaque DB Docker
#   command: >
#     docker exec -i {{ item.pg_host }}
#     psql -U {{ item.pg_user }} -d {{ item.pg_db }} -c "
#     INSERT INTO users (
#       email, name, password,
#       \"isSystem\", \"isActive\", \"isVerified\", \"mustChangePwd\", \"tfaIsActive\",
#       \"providerKey\", \"providerId\",
#       \"createdAt\", \"updatedAt\",
#       \"localeCode\", \"defaultEditor\", \"timezone\",
#       \"lastLoginAt\", \"dateFormat\", \"appearance\"
#     ) VALUES (
#       '{{ item.admin_email }}',
#       'Administrator',
#       '{{ item.admin_password }}',
#       false, true, true, false, false,
#       (SELECT \"key\" FROM authentication WHERE \"strategyKey\"='local' LIMIT 1),
#       '',
#       to_char(NOW(), 'YYYY-MM-DD\"T\"HH24:MI:SS\"Z\"'),
#       to_char(NOW(), 'YYYY-MM-DD\"T\"HH24:MI:SS\"Z\"'),
#       'en', 'markdown', 'America/Toronto',
#       to_char(NOW(), 'YYYY-MM-DD\"T\"HH24:MI:SS\"Z\"'),
#       'YYYY-MM-DD', 'default'
#     )
#     ON CONFLICT (\"providerKey\", email) DO UPDATE
#     SET \"password\" = EXCLUDED.\"password\",
#         \"updatedAt\" = EXCLUDED.\"updatedAt\",
#         \"isActive\" = true,
#         \"isVerified\" = true;"
#   changed_when: false
#   loop: "{{ wikis_docker }}"
#   loop_control:
#     label: "{{ item.name }}"
